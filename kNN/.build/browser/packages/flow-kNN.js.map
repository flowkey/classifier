{"version":3,"file":"/packages/flow-kNN.js","sources":["flow-kNN/lib/kNearestNeighbor.js","flow-kNN/lib/draw.js"],"names":[],"mappings":";;;;;;;;AAAA,2B;AACA,oB;AACA,e;AACA,8B;AACA,oB;AACA,qB;;AAEA,E;;AAEA,iC;;AAEA,yB;AACA,8B;AACA,M;;AAEA,iC;;AAEA,gD;AACA,oE;;AAEA,mD;;AAEA,uC;;AAEA,kE;AACA,gE;AACA,iB;;AAEA,kE;AACA,gE;AACA,iB;;AAEA,a;AACA,S;;;AAGA,M;;AAEA,0C;AACA,4B;AACA,mC;AACA,oC;AACA,wD;AACA,yD;AACA,S;;AAEA,+B;AACA,oD;;AAEA,8B;AACA,8B;;AAEA,wB;AACA,+B;;AAEA,qC;AACA,M;;AAEA,kC;;AAEA,+B;;AAEA,U;AACA,6D;AACA,W;AACA,mC;;AAEA,sC;;AAEA,4E;AACA,kB;AACA,8C;AACA,mE;AACA,mB;;AAEA,iC;AACA,6C;AACA,2C;AACA,4C;AACA,gE;AACA,0E;AACA,iB;;;AAGA,uC;AACA,qE;;AAEA,sC;AACA,+C;;AAEA,gC;AACA,gD;AACA,gB;AACA,sD;;AAEA,a;AACA,S;AACA,K;AACA,G;;;;AAIA,8B;AACA,qB;AACA,qB;AACA,iB;AACA,E;;;;AAIA,yB;AACA,6B;AACA,gC;AACA,K;AACA,E;;AAEA,0B;;AAEA,iD;;AAEA,uC;AACA,sC;AACA,gD;;AAEA,wB;AACA,C;AACA,4C;;AAEA,qD;;AAEA,qE;;AAEA,sD;AACA,+C;AACA,kC;;AAEA,+C;;AAEA,uC;;AAEA,a;;AAEA,kD;AACA,S;AACA,M;;AAEA,gC;;AAEA,4C;AACA,2C;AACA,W;AACA,M;;AAEA,4B;AACA,uB;;AAEA,mD;AACA,6C;;AAEA,wC;AACA,yC;AACA,a;;AAEA,sC;AACA,S;;AAEA,qB;AACA,wB;AACA,oB;AACA,U;AACA,iC;AACA,4C;AACA,kC;AACA,0C;AACA,a;AACA,S;;AAEA,2B;;AAEA,qB;AACA,K;;AAEA,G;;;;;;;;;;;;;;;;;;;;ACtLA,iC;;;AAGA,2C;;AAEA,U;AACA,oD;AACA,W;AACA,6D;AACA,6D;;;AAGA,yD;AACA,yD;;AAEA,wD;AACA,0C;AACA,wB;AACA,yB;AACA,2C;;AAEA,mC;AACA,uB;;AAEA,2D;AACA,uE;AACA,yC;AACA,mC;AACA,0C;AACA,0B;AACA,mC;AACA,4C;AACA,0B;AACA,mC;AACA,2C;AACA,0B;AACA,wB;AACA,8C;AACA,a;;AAEA,6B;AACA,wD;AACA,0D;;AAEA,2H;AACA,4H;AACA,qC;;;AAGA,gC;AACA,4B;AACA,mD;AACA,uB;AACA,4B;;;AAGA,e;AACA,2E;AACA,e;AACA,2D;AACA,uE;AACA,oD;AACA,mD;AACA,uC;AACA,gD;AACA,8B;AACA,uC;AACA,kD;AACA,8B;AACA,uC;AACA,iD;AACA,8B;AACA,4B;AACA,oD;AACA,iB;;AAEA,kF;AACA,sC;AACA,gC;AACA,4D;AACA,6B;AACA,gC;;AAEA,a;;AAEA,0B;;AAEA,S;AACA,M;;AAEA,qC;AACA,oB;AACA,oE;AACA,sD;AACA,kD;AACA,a;AACA,U;AACA,0C;AACA,2F;AACA,S;AACA,+B;AACA,K;AACA,G","sourcesContent":["NodeManager = function(k) {\n    this.nodes = [];\n    this.k = k;\n    this.featureSpecList = [];\n    this.types = [];\n    this.toDraw = [];\n\n};\n\n_.extend(NodeManager.prototype, {\n\n    add: function(node) {\n        this.nodes.push(node);\n    },\n\n    calculateRanges: function() {\n\n        // for (var j in this.featureSpecList) {\n        for (var j = this.featureSpecList.length - 1; j >= 0; j--) {\n\n            var featSpec = this.featureSpecList[j];\n\n            for (var i in this.nodes) {\n\n                if (this.nodes[i][featSpec.name] < featSpec.min) {\n                    featSpec.min = this.nodes[i][featSpec.name];\n                }\n\n                if (this.nodes[i][featSpec.name] > featSpec.max) {\n                    featSpec.max = this.nodes[i][featSpec.name];\n                }\n\n            }\n        }\n\n\n    },\n\n    determineSingleUnkown: function(node){\n        node.neighbors = [];\n        for (var j in this.nodes) {\n            if (!this.nodes[j].type)\n                continue; //immediately start next cycle\n            node.neighbors.push(new Node(this.nodes[j]));\n        }\n\n        /* Measure distances */\n        node.measureDistances(this.featureSpecList);\n\n        /* Sort by distance */\n        node.sortByDistance();\n\n        /* Guess type */\n        node.guessType(this.k);\n\n        console.log(node.guess.type);\n    },\n\n    determineUnknown: function() {\n\n        this.calculateRanges();\n\n        /*\n         * Loop through our nodes and look for unknown types.\n         */\n        for (var i in this.nodes) {\n\n            if (!this.nodes[i].type) {\n\n                // console.log(\"determining unknown node: \", this.nodes[i]);\n                /*\n                 * If node doesn't have a type\n                 * clone the nodes list and then measure distances.\n                 */\n\n                /* Clone nodes */\n                this.nodes[i].neighbors = [];\n                for (var j in this.nodes) {\n                    if (!this.nodes[j].type)\n                        continue; //immediately start next cycle\n                    this.nodes[i].neighbors.push(new Node(this.nodes[j]));\n                }\n\n\n                /* Measure distances */\n                this.nodes[i].measureDistances(this.featureSpecList);\n\n                /* Sort by distance */\n                this.nodes[i].sortByDistance();\n\n                /* Guess type */\n                this.nodes[i].guessType(this.k);\n                \n                console.log(this.nodes[i].guess.type);\n\n            }\n        }\n    }\n});\n\n\n\nFeatureSpec = function(name) {\n    this.name = name;\n    this.min = 10000;\n    this.max = 0;\n};\n\n\n\nNode = function(object) {\n    for (var key in object) {\n        this[key] = object[key];\n    }\n};\n\n_.extend(Node.prototype, {\n\n    measureDistances: function(featureSpecList) {\n\n        for (var i in this.neighbors) {\n            /* Just shortcut syntax */\n            var curNeighbor = this.neighbors[i];\n\n            var sum = 0;\n \n            for (var j in featureSpecList) {\n\n                var curFeatSpec = featureSpecList[j];\n\n                var currentRange = curFeatSpec.max - curFeatSpec.min;\n\n                var a = curNeighbor[curFeatSpec.name];\n                var b = this[curFeatSpec.name];\n                var delta = a - b;\n\n                delta = (delta) / currentRange;\n\n                sum += (delta * delta);\n\n            }\n\n            curNeighbor.distance = Math.sqrt(sum);\n        }\n    },\n\n    sortByDistance: function() {\n\n        this.neighbors.sort(function(a, b) {\n            return a.distance - b.distance;\n        });\n    },\n\n    guessType: function(k) {\n        var types = {};\n\n        for (var i in this.neighbors.slice(0, k)) {\n            var neighbor = this.neighbors[i];\n\n            if (!types[neighbor.type]) {\n                types[neighbor.type] = 0;\n            }\n\n            types[neighbor.type] += 1;\n        }\n\n        var guess = {\n            type: false,\n            count: 0\n        };\n        for (var type in types) {\n            if (types[type] > guess.count) {\n                guess.type = type;\n                guess.count = types[type];\n            }\n        }\n\n        this.guess = guess;\n\n        return types;\n    }\n\n});\n\n","_.extend(NodeManager.prototype, {\n\n\n    draw: function(canvas_id, drawRadius) {\n\n        /*\n         * get features by name from featureSpecList\n         */\n        var featureX = this.getFeatureByName(this.toDraw[0]);\n        var featureY = this.getFeatureByName(this.toDraw[1]);\n\n\n        var featureX_range = featureX.max - featureX.min;\n        var featureY_range = featureY.max - featureY.min;\n\n        var canvas = document.getElementById(canvas_id);\n        var ctx = canvas.getContext(\"2d\");\n        var width = 400;\n        var height = 400;\n        ctx.clearRect(0, 0, width, height);\n\n        for (var i in this.nodes) {\n            ctx.save();\n\n            //this switch is limited to 3 differenct colors\n            //if there are more than 3 types, this code should improved\n            switch (this.nodes[i].type) {\n                case this.types[0]:\n                    ctx.fillStyle = 'red';\n                    break;\n                case this.types[1]:\n                    ctx.fillStyle = 'green';\n                    break;\n                case this.types[2]:\n                    ctx.fillStyle = 'blue';\n                    break;\n                default:\n                    ctx.fillStyle = '#666666';\n            }\n\n            var padding = 40;\n            var x_shift_pct = (width - padding) / width;\n            var y_shift_pct = (height - padding) / height;\n\n            var x = (this.nodes[i][featureX.name] - featureX.min) * (width / featureX_range) * x_shift_pct + (padding / 2);\n            var y = (this.nodes[i][featureY.name] - featureY.min) * (height / featureY_range) * y_shift_pct + (padding / 2);\n            y = Math.abs(y - height);\n\n\n            ctx.translate(x, y);\n            ctx.beginPath();\n            ctx.arc(0, 0, 5, 0, Math.PI * 2, true);\n            ctx.fill();\n            ctx.closePath();\n\n\n            /* \n             * Is this an unknown node? If so, draw the radius of influence\n             */\n            //this switch is limited to 3 differenct colors\n            //if there are more than 3 types, this code should improved\n            if (!this.nodes[i].type && drawRadius) {\n                switch (this.nodes[i].guess.type) {\n                    case this.types[0]:\n                        ctx.strokeStyle = 'red';\n                        break;\n                    case this.types[1]:\n                        ctx.strokeStyle = 'green';\n                        break;\n                    case this.types[2]:\n                        ctx.strokeStyle = 'blue';\n                        break;\n                    default:\n                        ctx.strokeStyle = '#666666';\n                }\n\n                var radius = this.nodes[i].neighbors[this.k - 1].distance * width;\n                radius *= x_shift_pct;\n                ctx.beginPath();\n                ctx.arc(0, 0, radius, 0, Math.PI * 2, true);\n                ctx.stroke();\n                ctx.closePath();\n\n            }\n\n            ctx.restore();\n\n        }\n    },\n\n    getFeatureByName: function(name){\n        var feature;\n        for (var i = this.featureSpecList.length - 1; i >= 0; i--) {\n            if (this.featureSpecList[i].name == name){\n                feature = this.featureSpecList[i];\n            }\n        };\n        if (typeof(feature) == undefined){\n            console.error(\"no feature found with the name '\"+parameters.featureX_name+\"'\");\n        }\n        return feature;        \n    }\n});"]}